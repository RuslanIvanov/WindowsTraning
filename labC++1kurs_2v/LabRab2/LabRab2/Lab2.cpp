/*************************************************************
	Практическое занятие №2. Побитовые операторы.
							Директивы препроцессора.
							Указатели.
*************************************************************/

//#include <iostream>
//#include <tchar.h>
//#include <cmath>

#define	  stop __asm nop	//с помощью директивы препроцессора задаем
							//макроподстановку
//#ifdef _UNICODE
// #include <wchar.h>
// typedef wchar_t TCHAR;
// #define _T(b) L##b _T
// #define _tmain wmain
// #define _tcscpy wcscpy
//#else
// #include <string.h>
// typedef char TCHAR;
// #define _T(b) b 
// #define _tmain main
// #define _tcscpy strcpy
//#endif

#include <iostream>
//#undef _UNICODE
#include <tchar.h>
#include <cmath>
#include <clocale>

 

using namespace std;  // все имена простр. имен STD делаем видимыми
int _tmain()
{
	setlocale(LC_ALL, ".866");
// ********************************************************
	//Задание 1. Побитовая арифметика (and, or, xor, not), сдвиги.
	//1.1
	{
	int y;//Задайте значение y, например, с помощью потока ввода
	cout<<"Enter Y:"<<endl;
    cin>>y;
	//С помощью побитовых операторов и операторов сдвига выведите значение "y"
	//на консоль в двоичном виде, например:
	//если y==9, то
	// а) 0 0 0 0 ...   0 0 1 0 0 1 (всего 32 двоичных цифры)
	int n = sizeof(int)*8; // кол_во разрядов int на данной платформе
	unsigned int mask = 1<< (n-1); //0x80000000
	//cout<<n<<endl;
	//cout<<mask<<endl;
	for(int i=0;i<n;i++)
	{if (y&mask)
	  cout<<1;
	 else  cout<<0;
	 mask>>=1;
	}
	//или пропустите незначащие нули - б) 1 0 0 1
  
	cout<<"Enter Y2:"<<endl;
    cin>>y;
	mask = 1<< (n-1); //0x80000000
	bool pri=false;
	//cout<<hex<<n<<endl;
	//cout<<hex<<mask<<endl;
    for(int i=0;i<n;i++)
	{
	 if (y&mask)
	  {cout<<1; pri=true;}
	 else if(pri) cout<<0;
	  mask>>=1;
	}
    mask = 1<< (n-1);
    /*for(int i=0;i<n;i++)
	{// с пом_ю двух for...

	}*/
stop
	}
		
	//1.2 Дана целая переменная
	{
	 int y;//Задайте значение y, например, с помощью потока ввода
	 int n = sizeof(int)*8;
	 int c=0;
	 unsigned int m1 = 1;
	 unsigned int mv = 1<< (n-1);
	 //unsigned int m2 = 1;
	 unsigned int x;
     cout<<"Enter Y3:"<<endl;
	 ///cout<<n;
     cin>>y;
		//"Сдвиньте" все единицы в сформированном значении вправо, например:
		//было:   0100 1111 0000 0000 0110 1111 0000 0010
		//стало:  0000 0000 0000 0000 0000 1111 1111 1111
	 //static_cast<unsigned int>(y); смысла нет, знаковость останется и размер тот же
     while (m1)
	 {if(y&m1)c++;
	 m1=m1<<1;}
	 y=~((1<<n-1)>>((n-1)-c));//100...000 ->  (n-1)-c) + инверсия
	 //cout<<y;// плохо при 2 т.е с одной 1
	 for(int i=0;i<n;i++)
	 {if (y&mv)
	  cout<<1;
	 else  cout<<0;
	 mv>>=1;
	 }
	}

stop
	//1.3 Какие операции следует применить к заданному ниже операнду sNum для
	//того, чтобы переменная sRes приняла требуемое значение?
	//Замечание 1: значения подобраны таким образом, что в каждом случае достаточно
	//использовать один оператор (и при необходимости маску) 
	//Замечание 2: посредством оператора xor (подобрав соответствующую маску)
	//можно получить любое значение => этот оператор предполагается использовать
	//в том случае, когда все остальные уже "не спасают" 
	{
	short sNum = 0x8008;
	short sRes;
    sRes = ~sNum;
	cout<<"\n"<<hex<<sRes<<endl;
	//0x7ff7
	sRes = sNum|0x0ff0;
	cout<<"\n"<<hex<<sRes<<endl;
	//0x8ff8
	sRes = sNum&0x8;
	cout<<"\n"<<hex<<sRes<<endl;
	//0x0008
	sRes = sNum^0xff00;
	cout<<"\n"<<hex<<sRes<<endl;
	//0x7f08
    sRes = sNum>>3; 
	cout<<"\n"<<hex<<sRes<<endl;
	//0xf001//???
    sRes = sNum<<1; 
	cout<<"\n"<<hex<<sRes<<endl;
	//0x0010
	}

	stop
// ********************************************************
	//Задание 2. Директивы препроцессора

	//2.1. Использование "математических" макросов стандартной библиотеки:
	//в заголовочном файле <cmath> (который в свою очередь включает старый
	//файл math.h) определены часто используемые математические
	//константы, например M_PI. Воспользуйтесь этой константой для
	//вычисления длины окружности.
	//Обратите внимание: определения констант в свою очередь тоже заключены
	//в директивы условной трансляции. Что еще, кроме подключения заголовочного
	//файла, требуется сделать???
     //2*pi*r
	{
    //#define M_PI 3.14
    double r =5.0; 
    double l=0.0;
    l = 2*M_PI*r;
	cout<<"\nl1= "<<l<<endl;
	}
    stop
	//2.2.Макросы с параметрами.
	//2.2.1 Напишите свою макроподстановку для вычисления длины окружности.
	{
    #define L(x) 2*M_PI*(x)
    double l=0.0;
    double r =5.0;
	l=L(r+5);
	cout<<"\nl2= "<<l<<endl;
	stop
	}
    
	



	//2.2.2 определите макрос MAX(A, B)  для вычисления б'ольшего
	//значения из двух.
	
	//Используйте макрос следующим образом. Следите за изменением
	//значений переменных k, i, j. Объясните результат.
	//Постарайтесь убрать побочные эффекты.
	//Отметьте случаи, когда избежать побочных эффектов невозможно
	{
    //#define MAX(A,B) if((A)>(B)) return((A)-(B)) else if((A)<(B)) return ((B) - (A)) else return ((A)-(B))
    #define MAX(A,B) (((A)>(B))?(A)-(B):(B)-(A))
	int i = 10, j = 12, k;
	k = MAX(i, j);// вместо макроса подст. тернальный оператор, возвращ_ий значение
				  //(((i)>(j))?(i)-(j):(j)-(i))
	cout<<"\nk= "<<k<<endl;
	k = MAX(j, i) * 2;// тело макроса нужно взять в ()
	                  //(((i)>(j))?(i)-(j):(j)-(i))*2
	cout<<"\nk= "<<k<<endl;
	
	k = MAX(j, i+3);//(((j)>(i+3))?(j)-(i+3):((i+3)-j)) 
	cout<<"\nk= "<<k<<endl;
	k = MAX(i--, j++);// (((i--)>(j++))?(i--)-(j++):(j++)-(i--))// со скобками болеее безопасно!
	cout<<"\nk= "<<k<<endl;

/**/  
    stop
	}
	//2.2.3 определите макрос EXCHANGE(X, Y)  для перестановки
	//двух объектов типа int в памяти местами. Проверьте для приведенного
	//фрагмента. Подумайте, что будет делать макроподстановка, если
	//переставляемые значения разного типа???
	// будет неявное преобразование теипа если это возможно///
  {
    #define EXCHANGE(X, Y) tmp=(X); (X)=(Y); (Y)=(tmp)
    int tmp;
	int x1=1, y1=-1;//dword ptr [y1],0FFFFFFFFh 
	//cout<<"\nDo x1="<<x1<<"y1="<<y1<<endl;
	printf("\nDo x1=%d,y1=%d",x1,y1);
    EXCHANGE(x1,y1);
	//cout<<"\nPosle x1="<<x1<<"y1="<<y1<<endl;
	printf("\nPosle x1=%d,y1=%d",x1,y1);

	int x2=100;
	int y2=-100;
	printf("\nDo x2=%d,y2=%d",x2,y2);
	EXCHANGE(x2,y2);
	printf("\nPosle x2=%d,y2=%d",x2,y2);
    
/**/
  }
stop
/*
	//2.3. Директивы условной трансляции
	//Выполняя следующий фрагмент, посмотрите, какое
	//значение принимает переменная iNN. Что нужно сделать
	//для того, чтобы результат был равен 0? 1? 2?
*/
int iNN;
//#define NNN
#define MMM
#if defined NNN && defined MMM
	iNN = 0;
#elif defined MMM
	iNN = 1;
#elif defined NNN 
	iNN = 2;

#else
	iNN = -1;
#endif

printf("\niNN=%d",iNN);
	stop

	


	//Задание 2.4. Загляните в Project/Properties -> диалоговая панель
	//- Property Pages/C\C++/Preprocessor/Preprocessor definitions.
	//В опциях командной строки в зависимости от мишени сборки проекта
	//(Debug или Release) может быть определено с помощью ключа /D
	//имя _DEBUG. С помощью директив условной
	//трансляции напишите фрагмент кода, который в зависимости от типа
	//мишени выводит с помощью cout разный текст на консоль. Проверьте
	//при разных мишенях сборки.
#ifdef _DEBUG
	printf("\nDEBUG ver\n");
#else
	printf("\nRELEASE ver\n");
#endif
	stop
	//Пусть
	//для мишени Debug в процессе выполнения данного участка
	//кода на экран выводится информация об
	//имени файла, номере строки с функцией вывода, дате и времени 
	//компиляции файла, содержащего данную функцию вывода,
	//а также имя функции, содержащей данную строку.

	//Для мишени Release должна быть просто выведена строка
	//"Release configuration!"

	//Подсказка: для получения нужной информации введите в инструментальном
	//окне 'Index' справочной системы следующую ключевую фразу:	Predefined Macros
	
	//Подсказка: мишень сборки проекта можно
	//поменять следующим образом - Build/Configuration Manager/Configuration
#ifdef _DEBUG
	//printf("\nFile __FILE__, __LINE__,__DATE__");
	cout<<"LINE: "<<dec<<__LINE__<<endl;
	cout<<"FILE: "<<__FILE__<<endl;
	cout<<"DATE: "<<__DATE__<<endl;
	cout<<"Function name:"<<__FUNCDNAME__<<endl;
#else
	printf("\nRelease configuration!");
#endif
	stop




	//Задание 2.5. Управляя определенностью идентификатора _UNICODE и используя
	//возможности заголовочного <tchar.h>, объявите и проинициализируйте однобайтовую
	//символьную переменную и расширенную (не изменяя исходный текст)
	//С помощью отладчика проверьте результат.
	{
     TCHAR c=_T('А');
    // cout<<"(_"<<c<<"_)"<<endl;
	 _tprintf(_T("%c"), c);
	 size_t ss=sizeof(c);
     stop
	}

// ********************************************************
	//Задание 3.Заголовочные файлы. Директива #include
	//3.1.Создайте и подключите к проекту два заголовочных файла 1.h и 2.h
	//В каждом заголовочном файле объявите перечисление с одинаковыми именами
	//констант, но сопоставьте именованным константам разные значения, например:
	//1.h - enum MyEnum{My1, My2, My3};  . 2.h - enum MyEnum{My1=5, My2, My3};
	//С помощью директив условной трансляции в DEBUG-версии пользуйтесь значениями
	//констант из 1.h, а в RELEASE-версии значениями констант из 2.h
#ifdef _DEBUG
#include "1h.h"
#else 
#include "2h.h"
#endif
printf("%d_%d_%d_%d",My0,My1,My2,My3);
 stop

// ********************************************************
/*
	//Задание 4. Указатели
	//Объявите объекты разных типов и проинициализируйте их.
	//Объявите указатели соответствующих типов и проинициализируйте их
	//адресами заданных объектов. 
	//Выполняя задание, с помощью отладчика посмотрите, какие значения
	//будут присвоены переменным-указателям и на что эти указатели
	//"указывают"*/
    char chrC='A';
    char* pchrC=&chrC;
	int intC=2;
	int* pintC=&intC;
    long int lintC=3;
	long int* plintC=&lintC; 
	float fC=115.5;
	float* pfC=&fC;
    double dC=0.024;
	double *pdC=&dC;
	stop

 /* //Задание 4а. Объявите указатель на тип char и проинициализируйте
	//его адресом строкового литерала. Присвойте переменной типа char значение
	//любого элемента строки.
	//Проверьте - возможно ли присвоить какое-либо значение по адресу,
	//задаваемому указателем?*/

	{
     char *pStr = "ABCDF";// комп отводит память для массива симв
	 char a;
	 a=(*(pStr+3));
	 printf("\nStr = %c",a);
	 //(*pStr) = 'S';// ошибка компол - выработано искл
	}
	stop


/*
	//Задание 5. Арифметика указателей. Операция разыменования указателя.
	//Выполняя задание, следите за изменением значений
	//указателей и значений объектов, на которые они указывают.
	//Интерпретируте наблюдаемые результаты*/
	{
		int nAr[3] = {1,3};
		int* pn = &nAr[0];
		(*pn)++;// к первоум элю масс. + 1	
		pn++;	// перемест. указ. на след_ий эл. масс.
        printf("\nnAr = %d,%d",nAr[0],nAr[1]);

		char cAr[]={'A','B','C','D'};
		char* pc = &cAr[0];
		(*pc)=(*pc)+5;//к первому эл массиваа + 5=>F
		printf("\n(*pc) = %c",(*pc));
		pc=pc+3; //адрес эл, отстоящ. о pc на 3	
        printf("\n(*pc) = %с",(*pc));
		printf("\n%c,%c,%c,%c",cAr[0],cAr[1],cAr[2],cAr[3]);

	
		double dAr[3]={1.0,2.0};
		double* pd1 = &dAr[0];
		double* pd2 = pd1;// указ pd2 присв адр сод в указ pd1 => адр dAr[0]
		(*pd2)+=2;//  к 1 эл масс + 2 = 3.0
		pd2+=2;// адр меняется на 2 для соотв типа pd2=pd2+2;
        cout<<"\ndAr[0]="<<dAr[0]<<"dAr[1]="<<dAr[1]<<endl;

		//Объясните результат выполнения операции
		//вычитания двух указателей
		pd1 = &dAr[0];
		pd2 = &dAr[1];
		int nNumber=pd2 - pd1;
        printf("\nnNumber=%d",nNumber);// результат = кол элем на кот отстоют друг от друга два указ
		//Сравните указатели pd2 и pd1 и с помощью cout
		//выведите результаты сравнения.
        if(pd1<pd2) 
			cout<<"\npd1<pd2"<<endl;
		stop
	}

/*
	//Задание 6. Явное преобразование указателя. Иногда возникает
	//необходимость одни и те же данные интерпретировать по-разному,
	//например, целое можно представить как совокупность четырех
	//байтов и работать с каждым байтом по отдельности. Для этого
	//нужно иметь возможность "указывать" как на целое, так и на байт. 
	//Следовательно, возникает необходимость явного преобразования
	//указателя. 
	//Подсказка: для правильной интерпретации этого задания воспользуйтесь
	//возможностями отладчика представлять данные в интересующем
	//Вас виде (в данном случае - в шестнадцатеричном) - для
	//этого используйте правую клавишу мыши,находясь в окне
	//переменных и изменяйте пункт - Hexadecimal display*/

    unsigned int nObject5=0x55667788;
	unsigned int* pnObject5=&nObject5;

	//Раскомментировав следующую строчку кода, обратите внимание
	//на сообщение компилятора - он не считает преобразование 
	//"легальным" (безопасным)*/
	unsigned char* pucObject5;
	//pucObject5=static_cast<unsigned char*>(pnObject5);	//(1)//cannot convert from 'unsigned int *' to 'unsigned char *'
	pucObject5=reinterpret_cast<unsigned char*>(pnObject5);	//а такое
				//преобразование - целиком на совести программиста.
				//Его можно применять, только четко представляя себе
				//результат преобразования (2)
    printf("\npucObject5 = %x",(*pucObject5));//0x88
	//Откомментируйте следующие строчки сс==..., p - изменился? *p=...
	char cc = *(pucObject5++);// разименование,затем сдвиг указ
	printf("\ncc1 = %x, *p = %x",cc,*pucObject5);
	cc = (*pucObject5)++;//сс присв указ_е значение а затем + 1
    printf("\ncc2 = %x,*p = %x",cc,*pucObject5);//0х77,0x78
	cc = ++*(pucObject5);//0х79,0х79
	printf("\ncc3 = %x,*p = %x",cc,*pucObject5);
	cc = *(++pucObject5);//сдвиг указ на 1 типа и разименов 0x66,0x66
	printf("\ncc4 = %x,*p = %x",cc,*pucObject5);
	stop


	//Задание 7. Void-указатель. 
	//Выполняя задание, посмотрите - какие значения присваиваются
	//void-указателю. Обратите внимание: средствами отладчика Вы
	//не можете посмотреть значения, на которые "указывает"
	//void-указатель
	void*	pVoid;	//объявление void-указателя
    //pVoid	0x0012fca8
	int	nObject3=5;
	char cObject3='A';
	int*	pInt = &nObject3;	
	pVoid=&nObject3;//пуст указ присв  адр объекта
	pVoid=&cObject3;
	pVoid=pInt;//пуст указ рисв адр указ на эл int
	stop
	//Прежде, чем раскомментировать следующую строчку, вспомните:
	//что нужно сделать, чтобы выражение стало корректным 	
 	//pInt=pVoid;//cannot convert from 'void *' to 'int *'
	pInt= static_cast<int*>(pVoid);
    stop  


	//Что нужно сделать для того, чтобы следующее закомментированное выражение
	//стало корректным?
	{
		const int n = 1;
		//... = &n;//????объявить слева void-указатель
		const void * pV = &n;
	}
    stop


	//7a. При выполнении следующего фрагмента посмотрите, какие неприятности
	//могут Вас ожидать при явном приведении типа void-указателя,
	//который в момент времени (1) указывает на double, к типу 
	//указателя на int (2) 

	double dObject3 = 33.33;
	pVoid = &dObject3;	//(1)

	int nTmp = *(static_cast<int*>(pVoid) ); //(2) //разн типы указ => получен стр рез
	// так делать не безопасно!
	printf("\nnTmp = %d",nTmp);
	stop

		//Задание 8. Модификатор const. В каждом из заданий
		//объявите указатель требуемого вида. Посредством каждого
		//указателя попробуйте:
		//получить значение по адресу
		//записать новое значение по адресу
		//модифицировать указатель

		//Задание 8a. Указатель является константой. 
	{
		 char c = 'B';
         char* const pc = &c;
		 //pc++;//нельзя модиф конст указ
		 (*pc)='c';
		 printf("\n*pc = %c",*pc);
	}
	stop	 


		//Задание 8б. Указываемое значение является константой.
	{
     const char c = 'C';  
	 const char* pc = &c;// указ на конст_е зн
	 pc++;
	//(*pc)='c';//you cannot assign to a variable that is const
	 printf("\n*pc = %c",*pc);
	}
	stop


		//Задание 8в. И указатель, и указываемое значение
		//являются константами. 
	{
	 const char c = 'D';  
     const char* const pc = &c;// указ на конст_е зн
	//pc++;//you cannot assign to a variable that is const
	 //(*pc)='c';//you cannot assign to a variable that is const
	 printf("\n*pc = %c",*pc);
	}
	stop


		//Задание 8г. Указатель на переменную, объявленную с
		//ключевым словом const. 
	const int nN = 1;

	//Объявите указатель и проинициализируйте его выражением - &nN	
    const int* pnN=&nN; 
	stop



	//Задание 9.При выполнении задания обратите внимание на то,
	//как наглядно отладчик "раскрывает" конструкции типа
	//"указатель на указатель" и на способы получения конечного
	//объекта по таким "иерархическим" указателям
	int	n1=1;

    //Объявите указатель pn и проинициализируйте его так, чтобы он
	//"указывал" на n1
	int* pn=&n1;

    //Объявите указатель ppn и проинициализируйте его так, чтобы он
	//"указывал" на pn
    int** ppn=&pn;

    //Объявите указатель pppn и проинициализируйте его так, чтобы он
	//"указывал" на ppn
    int*** pppn=&ppn;
  
	//С помощью указателей pn, ppn и ppn получите значение объекта n1
	//и присвойте его n2

	int n2=(*pn);
	printf("\nn2=%d",n2);
	n2=*(*ppn);
    printf("\nn2=%d",n2);
	n2=*(*(*pppn));
    printf("\nn2=%d",n2);
	stop
	return 0;
}//end main
