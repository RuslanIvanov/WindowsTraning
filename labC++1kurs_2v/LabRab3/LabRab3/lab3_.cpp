/*************************************************************
	Практическое занятие №3. Встроенные массивы.
							Динамическое выделение памяти.
							Простейшие алгоритмы сортировки и поиска.
							Сложные указатели.
							Ссылки.
*************************************************************/


#define	  stop __asm nop
#include <cstdlib>
#include <cstdlib>
#include <ctime>
#include <string>

#include  <iostream>
int main()
{

///////////////////////////////////////////////////////////////
//			Встроенные массивы                               //
///////////////////////////////////////////////////////////////
/*
	//Задание 1. Объявите трехмерный массив и сформируйте указанные
	//значения элементов следующим образом:
	//а) проинициализируйте массив при объявлении
	//б) объявите неинициализированный массив и присвойте значения элементам
	//	с помощью кода
	//					 |--------|		
	//				   / |3  3  3 |		
	//    			 |---------|3 |
    //			   / | 2  2  2 |3 |
	//			  |---------|2 |__|
	//			  | 1  1  1 |2 | /
	//			  | 1  1  1 |__| 
	//			  | 1  1  1 | /
	//			  |_________|
	//Средствами отладчика проверьте правильность Вашего решения.
	//в) найдите сумму элементов массива
	 
	//г) проинициализируйте массив при объявлении:
	//					 |--------|		
	//				   / |3  0  0 |		
	//    			 |---------|0 |
    //			   / | 2  0  0 |0 |
	//			  |---------|0 |__|
	//			  | 1  0  0 |0 | /
	//			  | 0  0  0 |__| 
	//			  | 0  0  0 | /
	//			  |_________|
  


	//д) Инициализация массивов строковыми литералами:
	//Объявите и проинициализируйте строковыми литералами два массива:
	//двухмерный массив и массив указателей. Поясните разницу в использовании
	//элементов таких массивов.
*/
	//a                           //строка// /*э*/
	int arr1[3][3][3] = {{{1,1,1},{1,1,1},{1,1,1}},{{2,2,2},{2,2,2},{2,2,2}},{{3,3,3},{3,3,3},{3,3,3}}};
	                     //----слой-------------// 
   stop
	//b 
    int arr2[3][3][3]; 
    int *p=&arr2[0][0][0];//
	for (int i = 0;i<(sizeof(arr2)/sizeof(int));i++)// кол строк
	{*p=i/(sizeof(arr2[0])/sizeof(int))+1;
	 ++p;
	}
	int Sum=0;
	int *ps=&arr2[0][0][0];
	for (int i = 0;i<(sizeof(arr2)/sizeof(int));i++)// кол строк
	{*ps=i/(sizeof(arr2[0])/sizeof(int))+1;
	 Sum+=(*ps);
	 ++ps;
	}

	int arr3[3][3][3] = {{1},{2},{3}};	

	char arr_string [5][5]={{"ABCD"},{"EFGT"}};
	//char* arr_string1 [5]={{"ABCD"},{"EFGT"}};// массив указателей//комп отводит место под два указ, кот указ  на начало строк
	const char* arr_string1 [5]={{"ABCD"},{"EFGT"}};// массив указателей//комп отводит место под два указ, кот указ  на начало строк
	//const запрещает модиф. (ошибка компил_а)
	char c1 = arr_string [0][1];
	char c2 = arr_string1 [0][1];
    arr_string [0][1] = 'm';
    //arr_string1 [0][1] = 'm';
	stop
///////////////////////////////////////////////////////////////
//			Динамическое выделение памяти                    //
///////////////////////////////////////////////////////////////
	//Задание2. Создайте динамический двухмерный массив с размерностями,
	//вычисляемыми в процессе выполнения программы - N*M.
	//Задайте значения элементов помощью генератора случайных чисел.
	//Найдите  сумму элементов.
	//Подсказка 1: для генерации случайных чисел используйте функцию
	//стандартной библиотеки - rand() (<cstdlib>)
	//Подсказка 2: На самом деле те значения, которые создаются генератором случайных
	//чисел являются «псевдослучайными», то есть при двух последовательных запусках
	//приложения Вы получаете две одинаковые последовательности значений.
	//Для того чтобы генерируемые "случайные" значения были разными при каждом 
	//запуске приложения используйте функции стандартной библиотеки srand() (<cstdlib>)
	//и time() (<ctime>).
	//Функция srand() осуществляет «привязку» начала генерации к указанному в качестве параметра значению.
	//Функция time() задает эту точку отсчета, считывая текущее время
	
	srand( time( 0 ) );
//#include <cstdlib>
//#include <cstdlib>
//#include <ctime> // выносим в начало
int N,M;
//srand();
N = rand()%8 + 2;
//srand();
M= rand()%8 + 2;
printf("---------------2-------------------\n");
std::cout<<"N="<<N<<std::endl;
std::cout<<"M="<<M<<std::endl;
int* pn=new int[N*M];
for (int i =0;i<(N*M);i++)
{ 
	pn[i]=rand()%10;
    
	if(!(i%M)) printf("\n");
	std::cout<<pn[i];
}
 //delete[] pn;
 //pn=0;
    printf("\n");
    stop
	//Задание2а. В сформированном массиве отсортируйте каждую строку по
	//убыванию значений. Используйте сортировку "выбором"
	{//1
    int n = N*M;
	for(int i=0; i<n-1; i++)  // n-1, так как последний автоматически окажется на своем месте
	{	
		int max = i; 
		for(int j=i+1; j<n; j++)
		{
		 if(pn[j]>pn[max])max=j;
		}
		int tmp = pn[max];
		pn[max] = pn[i];
		pn[i] = tmp;
    }
 	for (int i =0;i<(N*M);i++) //вывод!
     {if(!(i%M)) printf("\n");
	  std::cout<<pn[i];
     }
	}//1'
    //delete[] pn;
    //pn=0;
	stop
	//Задание2б. Объявите одномерный массив размерностью N.
	//Сформируйте значение i-ого элемента одномерного массива  
	//равным среднему значению элементов i-ой строки
	//двухмерного массива
    int *p1=new int[N]; //одномерный масс N разм
	int j=0;
	int Sum1=0;
    int **ppmas = new int*[N];
	for(int i=0;i<N;i++)
	 { 
      ppmas[i]=pn+i*M;
	 }
    for(int i=0;i<N;i++)
	{Sum1=0;
	 for(int j=0;j<M;j++)
	  {Sum1+=ppmas[i][j];
	   p1[i]=(Sum1/M);
	  }
	}
    
	printf("\n\n");
    for (int i=0;i<N;i++) //вывод!
     {std::cout<<p1[i];
	  printf("_");
     }
	//Подсказка - не забудьте освободить память!
    delete[] pn;
	delete[] p1;
	delete[] ppmas;
	ppmas=0;
    pn=0;
	p1=0;
	stop	
	/////////////////////////////////////////////////////////////////////
	//Задание 3. а) Напишите фрагмент кода, который вводит NN целых чисел с помощью
	//потока ввода в объявленный Вами встроенный одномерный массив, каждый раз
	//упорядочивая полученное значение по возрастанию
#if 0
	printf("\n---------------3-------------------\n");
	{//2
     const int NN = 10;
  	 int m[NN];
	 int max=0;
	 printf("\nEnter mass:\n");
	 for(int i = 0;i<NN;i++)
	 {printf("Enter m[%d]:",i);
	  std::cin>>m[i];
	  int max = i;
	  for(int j=0; j<=i; j++)
	   {if(m[j]>m[max])
	     { max=j;
           int tmp = m[max];
	       m[max] = m[i];
		   m[i] = tmp;
	     }
	    printf("%d[%d].",m[j],j);
	   }
	} 
	   
	 printf("\n\nMass:");  
   	 for(int i = 0;i<NN;i++)
	  {
	   printf("%d[%d].",m[i],i);
	  }
	}//2'
	stop
    
	//б) Простой поиск.
	//Модифицируйте предыдущее задание следующим образом:очередное значение
	//вводится в массив только при условии, что там еще такого нет (то есть 
	//дубли игнорируются
    {//3//через do_while
     printf("\n---------------3b-------------------\n");
     const int NN = 10;
  	 int m[NN];
	 int max=0;
	 printf("\nEnter mass2:\n");
	 int i =0;
     while(i<NN)
	 {printf("Enter m[%d]:",i);
	  std::cin>>m[i];
	  int max = i;
	  for(int j=0; j<i; j++)
	   {if(m[j]==m[i]) {printf("\nCopy!\n");i=i-1; break;}
        if(m[j]>m[i])
	     {max=j;
	      int tmp = m[max];
	      m[max] = m[i];
	      m[i] = tmp;
	     }
	   }
	  i=i+1;
	  for(int out=0;out<i;out++)
	   {printf("%d[%d].",m[out],out);
	   }
	 } 
	   
	 printf("\n\nMass2:");  
   	 for(int i = 0;i<NN;i++)
	  {
	   printf("%d[%d].",m[i],i);
	  }
	}//3'
	stop 
#endif
	 

	///////////////////////////////////////////////////////////////////////////
	//Задание 4.С помощью данной заготовки напишите программу,
	//которая:
	//вводит строки с клавиатуры с помощью cin>>...
	//в объявленный Вами двухмерный встроенный массив 5*80 элементов типа char;
	//признаком конца ввода является символ * (то есть строка - "*") или
	//заполнение массива (больше свободных строк нет);
	//сортировка строк в алфавитном порядке. Пояснение: крайне
	//не рекомендуется для сортировки сложных объектов физически
	//перемещать их в памяти. Намного эффективнее завести массив
	//указателей на соответствующие строки и перемещать только
	//указатели.

    //Подсказка: для лексиграфического сравнения строк пользуйтесь
	//функцией стандартной библиотеки strcmp(...), заголовочный файл <string>.

	
	//Определите необходимые значения как константы
 //STOP_STRING  -  "*"	//признак "прекратить ввод"
 //M  -  80	//максимальный размер одной строки
 //N  -  10	//максимальное количество строк в массиве
#if 0
	{
	const char STOP_STRING ='*';
	const int M=80;//M-1 => \0
	const int N=10;

	//Объявите двухмерный массив с именем cBuffer типа char и
	// размерностью N*M
	char cBuffer[N][M];
	char ch;// для хран симв

	//Объявите массив (с именем cPointers) указателей на строки
	//размерностью N
	char* cPointers[N];
    int i=0;
    int j=0;
	int nIndex=0;
	int iN=0;
	//Цикл ввода строк:
	//а) выведите приглашение для ввода
	printf("\nEnter string:\n");
	//б) пока не введена строка STOP_STRING или не заполнен весь массив
	while(i<N)// пока есть свободные строки
	{   //iN=i+1;//Для вывода 
		//ввод строки в массив cBuffer:
		//cin>>cBuffer[i];
		std::cin>>&cBuffer[i][0];
	    //если введена строка - признак окончания, то выйти из цикла
		if(cBuffer[i][0]==STOP_STRING){printf("STOP_STRING\n");iN=i;break;}
		//Присвойте элементу массива cPointers с индексом nIndex
		//указатель на строку с номером nIndex в массиве cBuffer
		cPointers[nIndex]=&cBuffer[i][0];
     nIndex++; 
     i++;
	 iN=i;
	}
    
	//Выдать диагностику о том, что прием строк завершен.
	printf("\nEnd enter string!!!");
	printf("\nSave string:\n");
    for(int k=0;k<iN;k++)
	 {
		 std::cout<<"str"<<"["<<k<<"]:"<<cBuffer[k]<<std::endl;
	 }


	//Теперь сортируем строки:
   
    //Цикл сортировки строк по методу "всплывающего пузырька" в
	//порядке возрастания. На каждой итерации - промежуточная печать 
	//отсортированных строк
	/*i=0;
    while (i<iN)
	  {//while
       for(int ks=0;ks<(M-1);ks++) ///0
	    {//for1
		 bool pri_sort=false;
         for(int i_str=0;i_str<M-ks-1;i_str++)
		  {//for2
           if(*(cPointers[i]+i_str)>*(cPointers[i]+i_str+1))
		    {char tmp= *(cPointers[i]+i_str);
		    *(cPointers[i]+i_str)=*(cPointers[i]+i_str+1);//переадрисуем
			*(cPointers[i]+1+i_str)=tmp;
			pri_sort=true;
		   }
		  }//for2'
		 if(pri_sort==false) break;
	    }//for1'
	   std::cout<<"\nsort out"<<"["<<i<<"]:"<<cBuffer[i]<<std::endl;
	   i++;
	  }//while'
    printf("\nSortMassString:\n");
    for(int kk=0;kk<iN;kk++)
	 {
		 std::cout<<"str"<<"["<<kk<<"]:"<<cBuffer[kk]<<std::endl;
	 }//*/
	printf("\n");
    for(int ks=0;ks<iN;ks++) 
	 {//for1
	   bool pri_sort=false;
        for(int i_str=0;i_str<iN-ks-1;i_str++)
		  {//for2
		   int result = strcmp(cPointers[i_str], cPointers[i_str+1]);
		   if(result>0)//string1 greater than string2
		    {char *tmp =cPointers[i_str];
		     cPointers[i_str]=cPointers[i_str+1];
			 cPointers[i_str+1]=tmp;
			 pri_sort=true;
		    } 
		  }//for2'
		std::cout<<"str"<<"["<<ks<<"]:"<<cPointers[ks]/*cBuffer[ks]*/<<std::endl;
		if(pri_sort==false) break;
	 }//for1'
    printf("\nSortMassString:\n");
    for(int k=0;k<iN;k++)
	 {
		 std::cout<<"str"<<"["<<k<<"]:"<<cPointers[k]<<std::endl;
	 }
    stop
 	}

	//Задание 5. Реализуйте задание №4, используя не встроенные,
	//а динамические массивы (массив?)
	//При этом необходимые параметры (размерности
	// массивов) сформируйте с помощью потока ввода
	{
	int nStringNumber;
	int nStringSize;
	int iN=0;
	const char STOP_STRING ='*';
	printf("\nEnter StringNumber:");
	std::cin>>nStringNumber;
	printf("\nEnter StringSize:");
	std::cin>>nStringSize;
    char * pMStr =new char[nStringNumber*nStringSize];
	char **ppMStr=new char*[nStringNumber];
	for(int i=0;i<nStringNumber;i++)
	 {ppMStr[i]=pMStr+i*nStringSize;
	 }
 
	//Цикл ввода строк:
	int i=0;
    while(i<nStringNumber)// пока есть свободные строки
	{std::cin>>ppMStr[i];
	  
	 //если введена строка - признак окончания, то выйти из цикла
	 if(ppMStr[i][0]==STOP_STRING){printf("STOP_STRING\n");iN=i;break;}
		//Присвойте элементу массива cPointers с индексом nIndex
		//указатель на строку с номером nIndex в массиве cBuffer
		//cPointers[nIndex]=&cBuffer[i][0];
     //nIndex++; 
     i++;
	 iN=i;
	} 
    //Выдать диагностику о том, что прием строк завершен.
	printf("\nEnd enter string!!!");
	printf("\nSave string:\n");
    for(int k=0;k<iN;k++)
	 {
		 std::cout<<"str"<<"["<<k<<"]:"<<ppMStr[k]<<std::endl;
	 }


	//Цикл сортировки строк по методу "всплывающего пузырька" в
	//порядке возрастания кода первого символа
    for(int ks=0;ks<iN;ks++) 
	 {//for1
	   bool pri_sort=false;
        for(int i_str=0;i_str<iN-ks-1;i_str++)
		  {//for2
		   int result = strncmp(ppMStr[i_str], ppMStr[i_str+1],1);
		   if(result>0)//string1 greater than string2
		    {char *tmp =ppMStr[i_str];
		     ppMStr[i_str]=ppMStr[i_str+1];
			 ppMStr[i_str+1]=tmp;
			 pri_sort=true;
		    } 
		  }//for2'
		std::cout<<"\nstr"<<"["<<ks<<"]:"<<ppMStr[ks]/*cBuffer[ks]*/<<std::endl;
		if(pri_sort==false) break;
	 }//for1'
    printf("\nSortMassString:\n");
    for(int k=0;k<iN;k++)
	 {
		 std::cout<<"str"<<"["<<k<<"]:"<<ppMStr[k]<<std::endl;
	 }
  
	
	  
		
	//Освобождение занятой памяти:
     delete [] ppMStr;
	 delete [] pMStr;
	 ppMStr=0;
     pMStr=0;
     stop
	}
#endif
	//Задание 6.Связь указателей и массивов. Задайте трехмерный
	//встроенный массив [3][3][3]. С помощью операторов [] и *
	//разными способами получите значение [2][2][2] - элемента.
	//Средствами отладчика проверьте правильность Вашего решения.
	{
    int Ar1[3][3][3]={{{1,1,1},{4,4,4},{8,8,8}}, {{5,5,5},{7,7,7},{2,2,2}}, {{3,3,3},{9,9,9},{6,6,6}}};
	int *pAr1 = &Ar1[0][0][0];
	int *p2=Ar1[0][0];
	int (*p)[3][3]=Ar1;// указ на слой
	printf("\nAr1[2][2][2]=%d",Ar1[2][2][2]);
    printf("\nAr1[2][2][2]=%d",*(*(*(Ar1+2)+2)+2));
    printf("\nAr1[2][2][2]=%d",*(*(*(p+2)+2)+2));
	printf("\nAr1[2][2][2]=%d",p2[3*3+3*3+3*2]); //???
	printf("\nAr1[2][2][2]=%d",p2[24]);

	stop
	}
/**/

	//Задание 7. Объявление и использование указателей на многомерные
	// массивы. Проинициализируйте трехмерный массив
	//double dArray[4][3][3] так, как показано на рисунке и напишите фрагмент
	//кода, который меняет местами значения элементов четных
	//и нечетных слоев:
	//	было:			     |--------|		
	//  				   / |4  4  4 |		
	//					 |--------|	4 |	
	//				   / |3  3  3 |	4 |	
	//    			 |---------|3 |   |
    //			   / | 2  2  2 |3 | /
	//			  |---------|2 |__|
	//			  | 1  1  1 |2 | /
	//			  | 1  1  1 |__| 
	//			  | 1  1  1 | /
	//			  |_________|

	//	стало:			     |--------|		
	//  				   / |3  3  3 |		
	//					 |--------|	3 |	
	//				   / |4  4  4 |	3 |	
	//    			 |---------|4 |   |
    //			   / | 1  1  1 |4 | /
	//			  |---------|1 |__|
	//			  | 2  2  2 |1 | /
	//			  | 2  2  2 |__| 
	//			  | 2  2  2 | /
	//			  |_________|

	double dArray[4][3][3]={{{1,1,1},{1,1,1},{1,1,1}},{{2,2,2},{2,2,2},{2,2,2}},{{3,3,3},{3,3,3},{3,3,3}},{{4,4,4},{4,4,4},{4,4,4}}};
	double (*pdAr)[3][3]= dArray;// указатель на 1 слой
	double *p_str=dArray[0][0];
	double *p_el=&dArray[0][0][0];// указатель на 1 эл
	const int nN = sizeof(dArray)/sizeof(dArray[0]); //всего слоев
	const int nNN = sizeof(dArray[0])/sizeof(dArray[0][0][0]);//кол_во элементов в слое
	const int nNNN = sizeof(dArray)/sizeof(dArray[0][0][0]); // колличество эл в массиве
	
	for(int i=0; i<nN-1;)
	  {double *p7=reinterpret_cast<double*>(&dArray[i]);// указ на начало слоя i
       double *p8=reinterpret_cast<double*>(&dArray[i+1]);//указ на начало слоя i+1
	   for(int j=0; j<nNN;j++)
	    {double tmp = *(p7+j);
	     *(p7+j) = *(p8+j);
		 *(p8+j)=tmp;
	    }
	   i=i+2;
	  }
	printf("\nSl:");
	for(int i=0;i<nNNN;i++)
	{printf("%1.1f  ",*(p_el+i));}
	stop

	///////////////////////////////////////////////////////////////////////////
	//Задание 8а. Объявите двухмерный встроенный массив элементов типа char.
	//Заполнить строки двухмерного массива char с помощью генератора случайных 
	//чисел звездочками ('*') - то есть, если в строке десять элементов, то десять раз
	//следует получить с помощью генератора случайных чисел значение в диапазоне
	//0-9 и элементу с вычисленным таким способом индексом присвоить код символа '*'.
	//Очевидно, что при таком заполнении массива для некоторых элементов значение
	//заносится несколько раз, а для некоторых - ни разу.

	//В каждой строке "сдвиньте звездочки" в начало строки, например:
	//было - '*' '_' '_' '*' '*' '_' '*' '_' '*' '_'
	//стало: '*' '*' '*' '*' '*' '_' '_' '_' '_' '_'
	//и распечатайте массив по строкам - "постройте распределение"
	{char cArr [10][15];
	 char *p=&cArr[0][0];
	 int ind=0;
	 const int N =sizeof(cArr)/sizeof(cArr[0]);
	 const int M=sizeof(cArr[0])/sizeof(char);
	 
    for(int i = 0;i<N;i++)
	{//1
     for(int j=0;j<M;j++)
	 {//2
   	  cArr[i][j]=' ';
	  for(int k=0;k<M;k++)
	  {//3
       ind = rand()%M;
	  }//3'
	  cArr[i][ind]='*';
	 }//2'
	}//1'
   printf("\nFirst:");
   for(int i=0;i<(N);i++)
	 {printf("\n");
	  for(int j=0;j<M;j++)
	  {printf("%c",cArr [i][j]);
	  }
	 }
   ///
   for (int i=0;i<N;i++)
   {//for1
    for(int j=0;j<M-1;j++)
	 {int pr=j;// Пусть ' '
	  for(int k=j+1;k<M;k++)
	   {if((cArr[i][pr]=='*')&&(cArr[i][k]==' '))
	     pr=k;
	    char tmp = cArr[i][pr];
        cArr[i][pr]=cArr[i][k];
		cArr[i][k]=tmp;
	  
	   } 
	}
   }//for1'
   ///
    printf("\nTwo:");
	for(int i=0;i<(N);i++)
	 {printf("\n");
	  for(int j=0;j<M;j++)
	  {printf("%c",cArr [i][j]);
	  }
	 }
    }	
   stop




	// 8б. Модифицируйте предыдущее задание следующим способом:
	//После заполнения массива с помощью генератора случайных чисел
	//"сдвиньте" звездочки по столбцам вниз и распечатайте полученное
	//"распределение"
    {
	 char cArr [10][15];
	 char *p=&cArr[0][0];
	 int ind=0;
	 const int N=sizeof(cArr)/sizeof(cArr[0]);
	 const int M=sizeof(cArr[0])/sizeof(char);
	 
     for(int i = 0;i<N;i++)
	 {//1
      for(int j=0;j<M;j++)
	   {//2
   	    cArr[i][j]=' ';
	    for(int k=0;k<M;k++)
	     {//3
          ind = rand()%M;
	     }//3'
	    cArr[i][ind]='*';
	  }//2'
	}//1'
    printf("\nFirst2:");
    for(int i=0;i<(N);i++)
	 {printf("\n");
	  for(int j=0;j<M;j++)
	 {printf("%c",cArr [i][j]);
	 }
	}
   ///
   for (int j=0;j<M;j++)
   {//for1
    for(int i=0;i<N-1;i++)
	 {int pr=i;// Пусть ' '
	  for(int k=i+1;k<N;k++)
	   {if((cArr[pr][j]==' ')&&(cArr[k][j]=='*'))
	     pr=k;
	    char tmp = cArr[pr][j];
        cArr[pr][j]=cArr[k][j];
		cArr[k][j]=tmp;
	  
	   } 
	}
   }//for1'
   ///
   printf("\nTwo2:");
   for(int i=0;i<(N);i++)
    {printf("\n");
     for(int j=0;j<M;j++)
      {printf("%c",cArr [i][j]);
	  }
	 }
    }
    stop

	/////////////////////////////////////////////////////////////////////////////
	// Задание 9. Ссылки.
	//Объявите ссылку на тип double. Посредством ссылки измените значение
     double aa=1;
	 double &raa=aa;
	 raa++;
	 printf("\naa %f",aa);


	//Раскомментируйте следующую строку. Что следует сделать, чтобы
	//linker не выдавал ошибки при создании exe-файла
	//extern int& ref;
	 int bb=1;
	 int &ref=bb;
     // либо это объявление и инициализацию в др.файле проекта 
       stop
 
       
	//Раскомментируйте следующую строку. Что следует сделать, чтобы
	//компилятор не выдавал ошибки 
	const int& ref1 = 1;// компил создает фиктивную переменную



	//Задан указатель:
	char c='A';
	char* pc = &c;//&c псевданим с 
	//Объявите ссылку на указатель. Посредством ссылки измените
	char *&rpc = pc;
	//а) значение по адресу
      *rpc='D';
	  printf("\nc=%c",c);
	//б) сам адрес
	   rpc=rpc+1;
    printf("\nc=%c",*rpc);
	
stop
	return 0;
}