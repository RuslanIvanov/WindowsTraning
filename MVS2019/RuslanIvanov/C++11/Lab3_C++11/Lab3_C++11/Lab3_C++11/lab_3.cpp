
#include <string>
#include <iostream>
#include <cstdint>
#include <algorithm>
#include <iterator>
#include <memory>
#include <vector>
#include <list>

using namespace std;
#include "Header.h"
#include "classRange.h"

#if  _WIN32 

#define	  stop __asm nop
#include <tchar.h>

#else

#define _tmain main
#define _TCHAR char 

void mystop()
{//Linux
	std::cout << "\nPause\n";
	getchar();
}

#define  stop  {mystop();}
#endif

int main(int,char**)
{
	
	//Задание 1. Сырые строковые литералы (Raw String Literals)
	//Выведите строку, например: my name is "Marina"
	//а) без использования Raw String Literals
	//б) посредством Raw String Literals
	//в) добавьте разделители (Delimeter)

	{
		std::cout<<std::endl<< "my name is \"Ruslan\"";
		std::cout << std::endl << R"(my name is "Ruslan")";
		//delimiter:
		std::cout << std::endl << R"abc(my name is "Ruslan")abc";
		__asm nop
	}

	//////////////////////////////////////////////////////////////////////////////////////////////
	//Задание 2. Реализуйте вычисление факториала с помощью constexpr-функции.
	//
	//Подсказки/напоминания: 
	//		- constexpr – функция должна состоять из единственной инструкции return <выражение>; (пока!)
	//		- но это выражение может включать вызов другой constexpr – функции, в частности рекурсивный
	//		  вызов 
	//		- если параметр рекурсивной constexpr- функции - это константа, компилятор вычислит результат
	//		  на этапе компиляции

	//Проверьте тот факт, что компилятор вычисляет значение на этапе компиляции (если в качестве
	//				параметра используется константа, известная компилятору на этапе компиляции).
	//				Для проверки достаточно создать встроенный массив с размерностью, вычисляемой
	//				посредством constexpr-функции:

	{	//Например:
		constexpr unsigned int rez = factorial(3);// 3 известна на момент компил
		std::cout << std::endl<<"rez = "<<rez;

		int ar[factorial(3)];
		std::cout << std::endl;
		std::cout << "size ar " << std::size(ar);
		
		//или
		constexpr int n = factorial(5);//5 и n известны на момент компиляции
		int ar1[n];
		std::cout << "\nsize ar1 " << std::size(ar1);
		stop
		//попробуйте:
		int m = 7;
		/*constexpr int n1 = factorial(m);// error m - не известна на этапе компиляции
		int ar2[n1];
		std::cout << "\nsize ar2 " << std::size(ar2);//*/
		//а так?
		int n2 = factorial(m);// генерирует обычный вызов ф_ии
		//int ar3[n2];//err
		__asm nop
	}
	
	//////////////////////////////////////////////////////////////////////////////////////////////
	//Задание 3a. Перевод с помощью пользовательского литерала из двоичного представления строкового
	//в значение, например: строку "100000000" -> в значение 256
	//Проверить результат посредством префикса 0b
	//Чтобы вызов пользовательского литерала выглядел просто и читаемо, например: 100000000_b
	//логично использовать пользовательский литерал с единственным параметром - const char*

	//Так как речь идет о литералах, логично вычислять значения на этапе компиляции
	// => реализуйте пользовательский литерал посредством constexpr - функций
	//Подсказка/напоминание: 
	//		- constexpr – функция должна состоять из единственной инструкции return <выражение>;
	//		- но это выражение может включать вызов другой constexpr – функции,
	//		- которая может быть рекурсивной (если параметр такой функции - это константа,
	//		  компилятор вычислит результат вызова рекурсивной функции на этапе компиляции)

	{
		int b = 0b100000000;
		int test  = conv("100000000");
		std::cout << std::endl << "test conv() = " << test;
		int test2 = conv2("100000000");
		std::cout << std::endl << "test conv2() = " << test2;
		int test3 = conv3("100000000");
		std::cout << std::endl << "test conv3() = " << test3;
		constexpr int test4 = mypow(2, 3);
		std::cout << std::endl << "tes4  = " << test4;

		constexpr int bb = 100000000_b;
		int ar[bb];
		std::cout << std::endl << "ar size " << std::size(ar);
		if (b == bb) { std::cout << std::endl << " OK "; }//*/
		__asm nop

	}

	//Задание 3b. Перевод в строковое двоичное представление, например: 256 -> "0b100000000"
	//Так как строка может быть любой длины, логичнее и проще возвращать объект std::string
	//=> возвращаемое значение не может быть constexpr!
	//Подсказка: манипулятора std::bin пока нет => преобразование в двоичную строку
	//придется делать вручную
	//Подсказка: количество разрядов в байте определяет константа CHAR_BIT - <cstdint>

	{
		
		std::string sBinTest = 131_toBinStr;
		std::cout << std::endl << "bin test " << sBinTest;
		std::string sBin = 256_toBinStr;
		std::cout << std::endl << "bin " << sBin;
			
		stop 
	}

	//////////////////////////////////////////////////////////////////////////////////////////////
	//Задание 4а. constexpr - объекты 
	//Создать класс (шаблон класса?) для хранения и манипулирования диапазоном значений.
	//В классе должны быть:
	//	переменные для хранения минимального и максимального значений,
	//	методы для получения каждого из значений
	//	метод для проверки - попадает ли указанное значение в диапазон
	//	метод, который получает любое значение данного типа и формирует результирующее значение:
	//							если принадлежит диапазону, то его и возвращаем
	//							если меньше минимального значения, возвращаем минимальное
	//							если больше максимального значения, возвращаем максимальное

	//Проверьте тот факт, что компилятор вычисляет значение на этапе компиляции. 
	//				Для проверки достаточно создать встроенный массив с размерностью, вычисляемой
	//				посредством constexpr-метода:
	{
		
		c_range<int> rangeInt(10, 200);// no constexpr
		rangeInt.setValue(50);
		if (rangeInt.operator==(88)) { std::cout << "\nin range: " << rangeInt;  }
		else { std::cout << "\nno in range: " << rangeInt; }

		if (rangeInt.operator==(8)) { std::cout << "\nin range: " << rangeInt; }
		else { std::cout << "\nno in range: " << rangeInt; }

	    constexpr unsigned  char v = c_range<unsigned char>(5, 255).setValue(33);
		stop
		constexpr c_range<unsigned short> c(6,300,88);
		
		char ar[c.getValue()];
		__asm nop
	}	

	//////////////////////////////////////////////////////////////////////////////////////////////
	//Задание 5. unique_ptr
	{

		//5.а - обеспечьте корректное выполнение фрагмента
		{
			std::vector<std::string*> v = { new std::string("aa"), new std::string("bb"), new std::string("cc") };
			//Распечатайте все строки
		
			__asm nop
			for (size_t i = 0; i < v.size(); i++)
			{
				//std::cout << "\nstr: " << v[i]->c_str();
				std::cout << "\nstr: " << *v[i];
			}
			//???
			stop
			for (size_t i = 0; i < v.size(); i++)
			{
				delete v[i];
		
			}
			stop
		} //???// дестр, для вектора + нужно удалить строки
		stop
			//5.b - модифицируйте задание 5.а:
			 //обеспечьте посредством std::unique_ptr: 
			 //эффективное заполнение (вспомните про разные способы формирования std::unique_ptr), 
			 //безопасное хранение указателей на динамически создаваемые объекты std::string, 
			 //манипулирование,
			 //и освобождение ресурсов
			 //

		{/*
		 unique_ptr не может быть скопирован или задан через операцию присвоения. 
		 Неконстантный unique_ptr может передать владение управляемым объектом другому указателю unique_ptr. 
		 const std::unique_ptr не может быть передан, ограничивая время жизни управляемого объекта областью, 
		 в которой указатель был создан. Когда unique_ptr уничтожается, он удаляет объект с помощью Deleter.

		 Существует две версии std::unique_ptr:
		 1) управляет временем жизни одного объекта, например, созданного с помощью оператора new
		 2) управляет временем жизни массива, с длиной, определенной во время выполнения, созданного с помощью new[]
		 Типичные случаи применения std::unique_ptr включают:
		- обеспечение безопасности исключений для классов и функций, которые управляют объектами с динамическим временем жизни,
		 гарантируя удаление в случае нормального завершения и завершения по исключению
		-	передача владения динамически созданным объектом в функции
		-	получение владения динамически созданным объектом из функций
		-	в качестве типа элемента в контейнерах, поддерживающих семантику перемещения, 
			таких как std::vector, которые хранят указатели на динамически выделенные объекты 
			(например, если желательно полиморфное поведение)
		 */
			//Распечатайте все строки
			std::unique_ptr<std::string*[]>ptrV = make_unique<std::string*[]>(3);
			ptrV[0] = new string("s1");
			ptrV[1] = new string("s11");
			ptrV[2] = new string("s111");

			for (size_t i = 0; i < 3; i++)
			{
				std::cout << "\n " << *ptrV[i];
			}

			//??list
			std::initializer_list<std::unique_ptr<string>> list = { std::unique_ptr<string>(new std::string("aa")), std::unique_ptr<string>(new std::string("bb")), std::unique_ptr<string>(new std::string("cc")) };
			//?? видимо нужен move, так как список инициализации требует исп. классического к_копирования, кот. запрещено
			vector<std::unique_ptr<string>> vs;// = { std::unique_ptr<string>(new std::string("aa")),  std::unique_ptr<string>(new std::string("bb")) };
			vs.push_back(std::unique_ptr<string>(new std::string("aaa")));//push_back(T &&)
			vs.push_back(std::unique_ptr<string>(new std::string("bbb")));
			vs.push_back(std::unique_ptr<string>(new std::string("ccc")));
		    for (size_t i = 0; i < vs.size(); i++)
		    {
				std::cout << "\nstr vs: " << *vs[i];
			}

			__asm nop
		 //??? Уничтожение динамически созданных объектов?
		} //???
		stop
		{//5.c - дополните задание 5.b добавьте возможность изменять хранящиеся строки
		 //следующим образом (например, добавить указанный суффикс: "AAA" -> "AAA_1")  
		
			vector<std::unique_ptr<string>> vs;
			vs.push_back(std::unique_ptr<string>(new std::string("aaa")));
			vs.push_back(std::unique_ptr<string>(new std::string("bbb")));
			vs.push_back(std::unique_ptr<string>(new std::string("ccc")));
			for (size_t i = 0; i < vs.size(); i++)
			{
				std::cout << "\nstr vs: " << *vs[i];
			}
	
		
			transform(vs.begin(), vs.end(), vs.begin(), myModyString("_1"));

			for (size_t i = 0; i < vs.size(); i++)
			{
				std::cout << "\nmody str vs: " << *vs[i];
			}
			__asm nop
		}

		{//5.d - динамический массив объектов	

		 //Создайте unique_ptr, который является оберткой для динамического массива
		 //с элементами std::string
		 //С помощью unique_ptr::operator[] заполните обернутый массив значениями
		 //Когда происходит освобождения памяти?
			std::unique_ptr<std::string[]>ptrV4(new string[3]);
			for (int i = 0; i < 3; ++i)
			{
				ptrV4[i] = string("bbb");//move 
			}

			for (size_t i = 0; i < 3; i++)
			{
				std::cout << "\nstr: " << ptrV4[i];
			}

			__asm nop
		}//освобождение ~ptrV4 => delete[] 

		{//5.e - массивы динамических объектов и пользовательская delete-функция (функтор)
		 //Задан стековый массив указателей на динамически созданные объекты
		 //Создайте unique_ptr для такого массива
		 //Реализуйте пользовательскую delete-функцию (функтор) для корректного 
		 //освобождения памяти

			std::string* arStrPtr[] = { new std::string("aa"), new std::string("bb"), new std::string("cc") };
			
			//std::unique_ptr<string*[], std::default_delete< string*[] >> p(arStrPtr);//??? -  не удаляет строки - error
		  
			myDelString killer(3);// OK
			std::unique_ptr<string*[],decltype(killer)> p(arStrPtr, killer);
			
			//std::unique_ptr<string* [], decltype(&delMass)> p(arStrPtr, delMass(arStrPtr, 3));//?? error ??
			//std::unique_ptr<string*[], void(*)(string**,size_t n)> p(arStrPtr,delMass);//?? error ??
			std::cout << "\n# " << *p[0];
			std::cout << "\n# " << *p[1];
			std::cout << "\n# " << *p[2];//*/

		
			__asm nop
		}

		{//5.f Создайте и заполните вектор, содержащий unique_ptr для указателей на std::string
			//Посредством алгоритмя copy() скопируйте элементы вектора в пустой список с элементами 
			//того же типа
			//Подсказка: перемещающие итераторы и шаблон std::make_move_iterator
			std::string* s[] { new std::string("one"), new std::string("two"), new std::string("three") };
			vector<unique_ptr<string>>vv(std::make_move_iterator(std::begin(s)),std::make_move_iterator(std::end(s)));
			vv.push_back(std::unique_ptr<string>(new string("four")));
			for (size_t i = 0; i < vv.size(); i++)
			{
				std::cout << "\n# " << *vv[i];
			}

			std::list<unique_ptr<string>> l;
			
			std::copy(std::make_move_iterator(vv.begin()), std::make_move_iterator(vv.end()), std::back_inserter(l));
			//list<unique_ptr<string>>::iterator itl = l.begin();
			for (auto i = l.begin(); i != l.end(); ++i)
			{
				std::cout << "\n#l-> " <<*(i->get());
			}
			stop
			//vector<unique_ptr<string>>vvv;
			//std::copy(std::make_move_iterator(vv.begin()), std::make_move_iterator(vv.end()), std::back_inserter(vvv));
			//for (size_t i = 0; i < vvv.size(); i++)
			//{
			//	std::cout << "\n#vvv-> " << *vvv[i];
			//}
			__asm nop

		}
		__asm nop

	}

	////////////////////////////////////////////////////////////////////////////////
	//Задание 6.shared_ptr + пользовательская delete-функция 

	//Реализовать возможность записи в файл данных (строчек) из разных источников 
	//(для упрощения пусть источниками являются два массива)
	//Так как все "писатели" будут по очереди записывать свои данные в один и тот же файл,
	//логично предоставить им возможность пользоваться одним и тем же указателем FILE* =>
	//безопасной оберткой для такого указателя является shared_ptr
	//а. Первый владелец должен открыть/создать файл для записи
	//б. Все остальные писатели должны присоединиться к использованию
	//в. Последний владелец указателя должен закрыть файл

	//Подсказка: имитировать порядок записи можно с помощью функции rand()
	/*
	{

	//"писатели":
	//Создать writer1, writer2


	//например, источники данных:
	char ar1[] = "Writer1";
	char ar2[] = "Writer2";

	//заданное число итераций случайным образом позволяем одному из "писателей" записать в файл
	//свою строчку
	//Подсказка: строчки удобно записывать в файл посредством функции fputs()


	__asm nop
	}//закрытие файла???

	*/

	
}