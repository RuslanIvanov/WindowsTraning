// Темы:
// Простое наследование. Виртуальные функции. Абстрактные классы.
// Битовые поля.


#include <tchar.h>
#include <iostream>
#include "myString.h"
#include "myRect.h"
#include "Circle.h"
#include "Header.h"

#define	  stop __asm nop

int _tmain(int argc, _TCHAR* argv[])
{
	//MyString sss("qqq");
	//sss.GetString()[0] = 'W';// нельзя так как GetString возвр указательн на конст
	//Задание 1.Массив объектов класса.
	{
	//Объявите и проинициализируйте массив ar из объектов
	//типа MyString. 
		
	//const int N=3;
	const int N=5;
	MyString str1[N] = {MyString("1 string"),MyString("2 string"),MyString("3 string")};//в остальных констр по умолчаню при 5 N
  
	//Проверка - печать строк-членов класса
	for (int i = 0; i < N; i++)
	{
		if (str1[i].GetString() != nullptr)
		{
			std::cout << "\n#" << i << ": '" << str1[i].GetString() << "'";
		}
		else std::cout << "\n#" << i << " NULL";
	}

	//Замените размер const int N=5; , не изменяя список инициализаторов.
		

	}
	stop

	//Задание 2.Массив указателей на объекты класса.
	{
	//Объявите и проинициализируйте массив arPtr из N
	//указателей на объекты типа MyString.
	//const int N=3;
	const int N = 5;
	MyString* arPtr[N] = { new MyString("aaa"), new  MyString("bbb"), new MyString("ccc") }; //NULL, NULL -  правила не полной инициализации массива! - потому и NULL
	//Печать строк-членов класса
	for (int i = 0; i < N; i++)
	{
		if (arPtr[i] != nullptr)
		{
			std::cout << "\n#" << i << ": '" << arPtr[i]->GetString() << "'";
		}
		else std::cout << "\n#" << i << " NULL";
	}

	for (int i = 0; i < N; i++)
	{
		delete arPtr[i];// delete c nullptr работает корректно
	}
	
   	//Замените размер const int N=5; , не изменяя список инициализаторов.

	}
		stop


		//Задание 3.Простое наследование.Аргументы конструктора,
		// передаваемые в базовый класс.

		//Создайте иерархию классов:
		//базовый класс Shape (который описывает любую фигуру)
		//и два производных класса Rect и Circle.
		//Подумайте: какие данные и методы нужно ввести в базовый
		//и производные классы (например, любую фигуру можно сделать
		//цветной => в базовом классе можно ввести переменную, которая
		//будет определять цвет фигуры.
		//Подсказка: для хранения цвета объявите перечисление (RED,GREEN,BLUE...);


		//В конструкторах производных классов предусмотрите передачу
		//параметра-цвета конструктору базового класса.
		//При создании и уничтожении объекта производного типа определите
		//последовательность вызовов конструкторов и деструкторов базового
		//и производного классов
	{
		Rect rA;// деволтный конструктор базового, затем производного
		Rect rB(1,2,4,5,BLUE);  // конструктор c параметрами базового, затем производного
		Circle cA(3,5,10,RED);
		Circle cB(GREEN);
		rA.printColor();
		rB.printColor();
		cA.printColor();
		cB.printColor();
	}//дестр. производного, затем базового ()
	stop
//////////////////////////////////////////////////////////////////////

	//Задание 4.Виртуальные функции.
	//4а) Модифицируйте классы Shape,Rect и Circle:
	//добавьте в каждый класс public метод void WhereAmI().
	//Реализация каждой функции должна выводить сообщение 
	//следующего вида "Now I am in class Shape(Rect или Circle)".
	//Выполните приведенный фрагмент, объясните результат.

	//4б) Сделайте метод WhereAmI() виртуальным.
	//Снова выполните приведенный фрагмент, объясните разницу.

	{
		Shape s(BLUE);
		Rect r(1,2,5,9);
		Circle c(GREEN);

	
		//Метод какого класса вызывается в следующих строчках???
		s.WhereAmI();	//	посредством объекта вызывается соотв. метод класса Shape
		r.WhereAmI();	//	посредством объекта вызывается соотв. метод класса Rect
 		c.WhereAmI();	//	посредством объекта вызывается соотв. метод класса Circle
		stop


		Shape* pShape = &s; // адрес Shape к базовому
		Shape* pRect = &r; // компил . приводит адрес класса к базовому
		Shape* pCircle = &c; // компил . приводит адрес класса к базовому
    	pShape->WhereAmI();	//	посредством механизма вирт. функций вызов метода кл. Shape 
		pRect->WhereAmI();	//	посредством механизма вирт. функций вызов метода прозводного кл. Rect
		pCircle->WhereAmI(); //	посредством механизма вирт. функций вызов метода прозводного кл. Circle
		//если WhereAmI не вирт. в базовом, то  вызов Shape, Shape , Shape  стр. 114
		stop


		//Заполните ... согласно комментариям
		Shape& rShape = s; //псевдоним s
		Shape& rRect = r; //псевдоним r, приводит компил. адрес к базовому
		Shape& rCircle = c; //псевдоним c, приводит компил. адрес к базовому
		rShape.WhereAmI();	//посредством механизма вирт. функций вызов метода кл. Shape 
		rRect.WhereAmI();	//посредством механизма вирт. функций вызов метода прозводного кл. Rect
		rCircle.WhereAmI(); //посредством механизма вирт. функций вызов метода прозводного кл. Circle
		//*/
		stop
			
	}
		stop
//////////////////////////////////////////////////////////////////////

	//Задание 5.Виртуальные деструкторы.
	//Модифицируйте классы:
	//a) введите соответствующие
	// деструкторы (без ключевого слова virtual).
	//Реализация каждого деструктора
	//должна выводить сообщение следующего вида
	// "Now I am in Shape's destructor!" или
	// "Now I am in Rect's destructor!"
	//Выполните фрагмент. Объясните результат.

	//Отв: c virtual деструктор
	// вызов деструкторов по закр. скобке объекта с, затем его базовой части s, 
	// вызов деструкторов по закр. скобке объекта r, затем его базовой части s
	// вызов деструктора базового класса s

	stop
	// b) Добавьте в объявление деструкторов ключевое слово virtual 
	//Выполните фрагмент.Объясните разницу.

	//Отв: без virtual дестр
	//происходит вызов дестр также как и с вариантом выше, так объекты r,c,s не динамические (на этапе  компияции известно производному о базовом)
	
	stop
	//Подумайте: какие конструкторы вызываются в следующей строке?
		//Если в разработанных классов каких-то конструкторов
		//не хватает - реализуйте
		//Если Вы считаете, что в приведенном фрагменте чего-то
		//не хватает - добавьте

		Rect r(1,20,3,40,RED);
		Shape* ar[]={new Shape(r), new Rect(r), new Circle(r)/*??*/, new Circle() };
		//Вызовите для каждого элемента массива метод WhereAmI()
	
		for (int i = 0; i < sizeof(ar) / sizeof(ar[0]); i++)
		{
			ar[i]->WhereAmI();
			ar[i]->print();
		}
		stop
		for (int i = 0; i < sizeof(ar) / sizeof(ar[0]); i++)
		{
			delete  ar[i];// так как дестр.  вирт. и объекты созд. динамически то вызывается первым дестр производного, затем базового
		}
		stop
	//Задание 6*. В чем заключается отличие 1) и 2)
	{
		Shape* pShapes = new Rect[10];//1)массив указателей на базовый кл
		Rect* pRects = new Rect[10];//2)массив указателей на производный кл

		//1)  массив указателей из 10 эл. а память выделена под sizeof(Rect)*10, конструктор по умолчанию
		//2) ---//---

		//Попробуйте вызвать метод WhereAmI() для каждого элемента обоих массивов -
		//в чем заключается проблема???
		//проблема в том что проинициализирован только 1 элемент массива

		Shape* pS = pShapes;
		Rect* pR = pRects;
		Rect* ptmp = static_cast<Rect*>(pShapes);
		for (int i = 0; i < 10; i++)
		{
			if (pS != nullptr)
				pS->WhereAmI(); // вызов метода под средством мех. вирт. функ. => rect 
			stop
			if (pR != nullptr)
				pR->WhereAmI();// вызов метода под средством мех. вирт. функ. => rect
			stop

			pS = pS + sizeof(Rect);// сдвиг указателя на следущий объект Sahpe с учетом размерв Rect+Sahpe

			//static_cast<Rect*>(pShapes)[i].WhereAmI();
			ptmp[i].WhereAmI();

			pR++;;//сдвиг указателя на производный след объект
			stop
		}
		stop
		//Освободите динамически захваченную память
	
		delete  [] pShapes; // освобождаем столько, сколько  выделели Rect*10, вызов деструктора для каждого элемента массива
		delete  [] pRects; // --//-- вызов деструктора для каждого элемента массива
		
		stop
	}

//*/

//////////////////////////////////////////////////////////////////////

	//Задание 7.Виртуальные функции и оператор разрешения области видимости. 

	{
		Rect r(1,2,3,4,GREEN);
		Shape* p = &r;	
		p->WhereAmI();//Вызов метода  кл. Rect с помощью мех. вир. функ.
		stop

		//4a Оператор разрешения области видимости.
		//Посредством объекта r и указателя p вызовите виртуальную функцию
		//WhereAmI()класса Shape

		r.Shape::WhereAmI(); // на этапе компиляции явно сказано компилятору что вызвать, вызов под средств_м объекта
		p->Shape::WhereAmI(); // явно сказано что вызывать компилятору на этапе компил. что вызывать, без мех. вирт функций.
		stop	
	}
//*/

//////////////////////////////////////////////////////////////////////

	//Задание 8.Чисто виртуальные функции. 
	//Введите в базовый класс метод void Inflate(int); Подумайте:
	//можно ли реализовать такой метод для базового класса? => как его нужно объявить.
	//Реализуйте этот метод для производных классов.
	{//надо так:  virtual void Inflate(int) т.к. исп. указатель на базовый кл.
		Rect r(3,4,5,6,BLUE);
		Shape* p = &r;
		p->Inflate(5);
		Circle c(2,3,10,RED);
		p = &c;
		p->print();
		stop
		p->Inflate(5);
		p->print();
		p->printColor();
		stop
	}
//*/


//////////////////////////////////////////////////////////////////////
	//Задание 9. Создайте глобальную функцию, которая будет принимать любое
	//количество указателей на строки, а возвращать объект MyString,
	//в котором строка будет конкатенацией параметров
	const char* pstr1 = "one";
	const char* pstr2 = "two";
	const char* pstr3 = "three";
	MyString strs = ApplyString(pstr1, pstr2, pstr3,0);
	std::cout<<"\nrez: "<<strs.GetString();
	stop
////////////////////////////////////////////////////////////////////////

	//Задание 10.Объединения (union) C++. Битовые поля.
	//1.
	//Создайте следующие классы для различных представлений значений байта:
	//Bin - для двоичного представления
	//Hex - для шестнадцатерчного представления
	//Oct - для восьмеричного представления.
	//Подсказка 1: - для удобства используйте битовые поля.
	//Подсказка 2: - конструкторов в таких вспомогательных классах быть не должно,
	//так как все они будут членами объединения (union).
	//2.
	//В каждом классе введите метод Show, который должен выводить значение в
	//соответствующем виде
	//3.
	//Посредством объединения MyByte предоставьте пользователю возможность манипулировать
	//одним и тем же значением по-разному:
	//а) выводить: десятичное, шестнадцатеричное, восьмеричное, двоичное значение байта 
	//          а также символ, соответствующий хранимому значению (если есть соответствие);
	//б) выводить отдельные (указанные посредством параметра) шестнадцатеричные,
	//			восьмеричные, двоичные цифры;
	//в) изменять отдельные двоичные, восьмеричные или шестнадцатеричные цифры;

	MyBytes byte(0x1f);
	//MyBytes byte('c');
	//MyBytes byte(1);

	byte.ShowHex();
	byte.ShowBin();
	byte.ShowChar();
	byte.ShowOct();
	stop
	//...
	byte.ShowBinPos(0);
	byte.ShowHexPos(0);
	byte.ShowOctPos(0);

	byte.ShowBinPos(1);
	byte.ShowHexPos(1);
	byte.ShowOctPos(1);

	byte.EditBin(1, 1);// а изменения в одной и той же области памяти! 
	byte.ShowBin();//0000011
	byte.ShowHex();
	byte.ShowOct();

	byte.EditHex(1, 0x6);//0110
	byte.ShowBin();
	byte.ShowHex();
	byte.ShowOct();

	byte.EditOct(1, 4);//100
	byte.ShowBin();
	byte.ShowHex();
	byte.ShowOct();
	//...
	return 0;
}//endmain

