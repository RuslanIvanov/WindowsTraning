//Исключения

//Шаблоны: 
	//		шаблоны функций,
	//		шаблоны классов,

#include <tchar.h>
#include <iostream>
//#include <stdexcept>
#include "templ.h"
#include "MyString.h"
#include "MyStack.h"

#define stop __asm nop

int _tmain(int argc, _TCHAR* argv[])
{
	
	
	////////////////////////////////////////////////////////////////////////////
	//Тема. Шаблоны функций.
	//Создайте шаблон функции перестановки местами двух
	//значений - Swap(). Проверьте работоспособность созданного
	//шаблона с помощью приведенного ниже фрагмента кода.
	//Подсказка 1: объявление шаблона корректнее поместить в .h-файл.

	int iX = 1, iY = -1;
	Swap(iX, iY);

	stop

	double dX = 0.5, dY = -5.5;
	Swap(dX, dY);

	stop
	//Подсказка 2: подумайте, что нужно реализовать, для того,
	//			чтобы следующий вызов работал с объектами MyString
	//			не только корректно, но и эффективно
	MyString str1("One"), str2("Two");
	Swap(str1, str2);

	std::cout<<"\ns1 = "<< str1<<" s2 = " << str2;
	stop
		//*/
		/////////////////////////////////////////////////////////////////////

			//Тема. Шаблоны классов.
			//Задание 1.
			//Создайте шаблон класса MyStack для хранения элементов любого типа T.
			//Подсказка: 1.элементы нужно где-то хранить - простым и удобным средством
			//			для хранения последовательно расположенных в памяти элементов
			//			является массив, 
			//			2.для задания максимального размера стека может быть использован
			//			параметр-константа шаблона
			//			3.обязательными операциями со стеком являются "push" и "pop". Для
			//			того, чтобы гарантировать корректное выполнение этих операций 
			//			хорошо было бы генерировать исключение в аварийной ситуации
			//			4. дополнительно реализуйте operator[] таким образом, чтобы пользователь
			//			мог читать/изменять значения только тех элементов, которые он формировал


			//С помощью шаблона MyStack создайте стек из 5 элементов int - iStack и
			//стек из 10 элементов MyString - strStack и поэкспериментируйте с функциями
			//push() и pop(), operator[]
	/*{
		MyStack <int>st;
		try
		{
			for (int i = 0; i < 11; i++)
				st.push(i);
		}
		catch (const char* e)
		{
			std::cout << e;
		}
	
		std::cout << "\nstack:";
		for (int i = 0; i < st.size(); i++)
			std::cout << "\n#"<<i <<": "<<st.pop();
		stop
		try
		{
			for (int i = 0; ; i++)
				std::cout << "\n#"<<i<<" : "<< st.pop();
		}
		catch (const char* e) 
		{
			std::cout << e;
		}
		
		try
		{
			//st[0] = 0;
			//st[12] = 12;
			std::cout << "\noper[]:\n";
			std::cout << "\n#0: " << st[0];
			std::cout << "\n#12: " << st[12];
		}
		catch (ErrorStack & e)
		{
			std::cout << "\nout of range: index " << e.m_i << " size " << e.m_n;
		}
	}*/
	stop

	{
		MyStack <MyString>st;
		try
		{

			for (int i = 0; i < 11; i++)
			{
				char str[2];
				
				str[0] = i + 'A';
				str[1] = 0;
				st.push(str);
			}
		}
		catch (const char* e)
		{
			std::cout << e;
		}

		std::cout << "\nstack:";
		for (int i = 0; i < st.size(); i++)
			std::cout << "\n#" << i << ": " << st.pop();
		stop
		try
		{
			for (int i = 0; ; i++)
				std::cout << "\n#" << i << " : " << st.pop();
		}
		catch (const char* e)
		{
			std::cout << e;
		}

		try
		{
			//st[0] = "AAA";
			//st[12] = "BBB";
			std::cout << "\noper[]:\n";
			std::cout << "\n#0: " << st[0];
			std::cout << "\n#12: " << st[12];
		}
		catch (ErrorStack & e)
		{
			std::cout << "\nout of range: index " << e.m_i << " size " << e.m_n;
		}
		stop
	}
	stop


	//Задание 2. Реализуйте шаблон стека - MyStack2 таким образом, чтобы 
	//для хранения элементов использовался ОДНОСВЯЗНЫЙ список.
	//Реализуйте возможность распечатать элементы стека в том порядке, в котором их заносил (push())
	//пользователь






	

	return 0;
}

