КОНСТРУКТОР КОПИРОВАНИЯ И ОПЕРАТОР ПРИСВАИВАНИЯ В ОДНОСВЯЗНОМ СПИСКЕ
Это своего рода продолжение вопроса, который я задал вчера в своем задании с помощью односвязных списков. Я изо всех сил пытался создать конструктор копирования, оставив оператор присваивания до последнего, потому что я думаю, что они чем-то похожи на реализацию. Я думаю, что у меня есть шаги для создания конструктора копирования:

Создайте новый узел с новым списком в качестве параметра.
Пройдите по списку, добавив каждый узел из list1 в list2 (у меня есть функция добавления, которая, я думаю, поможет с этим?)
При этом увеличивайте значение через list2, чтобы каждый узел был правильно добавлен.
Пожалуйста, исправьте меня на любых шагах (или, возможно, мне нужно расширить на шагах). Я просмотрел много кода, найденного в Google, чтобы понять, что мне нужно делать, но моя реализация и понимание все еще должны быть нечеткими. Вот код, который у меня есть (код без комментариев — моя последняя попытка. Код с комментариями — это то, что я пробовал раньше, надеясь, что я по крайней мере на правильном пути):

template<typename T>
SLList<T>::SLList(const SLList<T> & lst2) : head() {
cout << "Calling copy constructor..." << endl;
for (Node *ptr = lst2.head; ptr != NULL; ptr = ptr->next) {
add(ptr->data);
}
}
Изменить: Спасибо WhozCraig за помощь мне с конструктором копирования выше.

А вот и add функция, на всякий случай ее можно использовать:

template<typename T>
void SLList<T>::add(const T& val) {
Node *prev = head;
for (Node *ptr = head->next; ptr != NULL; ptr = ptr->next) {
prev = ptr;
if (ptr->data == val) {
return;
}
}
prev->next = new Node(val);
}
То, что я думаю, может быть неправильным, хотя в строке 5 первого фрагмента кода, который я имею lst2.add(ptr->data); будет ли это назвать add функционировать и просто заменить ptr->data с val? Просто интересно, что если написать такую ​​строку, это не вызовет никаких ошибок.

Изменить: я забыл опубликовать этот фрагмент кода, а также. Он показывает мне создание двух целочисленных списков и попытку iList2 = iList; так что вызывается конструктор копирования. Я думаю, что, возможно, я сделал это неправильно, хотя.

void intList() {
SLList<int> iList;
cout << "\nNow showing integer list..." << endl;
iList.add(5);
iList.add(6);
iList.add(6);
iList.add(3);
iList.add(4);
SLList<int> iList2 = iList;
iList.print();
iList2.print();
}
Изменить 2: проблема конструктора копирования была исправлена ​​выше, но теперь, когда add функция вызывается, она падает на for петля. Может ли это быть потому, что lst2 это const объект и add это не const функция, как сказал WhozCraig?

Редактировать 3: Моя попытка присвоения оператора, на всякий случай:

template<typename T>
const SLList<T>& SLList<T>::operator=(const SLList & rhs) {
cout << "\nCalling assignment operator..." << endl;
// Step (1) Delete the existing list
while (head != NULL) {
Node *temp = head;
head = head->next;
delete temp;
}
// Step (2) Build a new, copy list
if (this != &rhs) {
for (const Node *ptr = rhs.head; ptr != NULL; ptr = ptr->next) {
add(ptr->data);
}
}
return *this;
}