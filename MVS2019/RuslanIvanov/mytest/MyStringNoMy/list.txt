template< typename T >
class List {
private:
   
    struct Node;

public:
    List(): m_head(NULL) { }
    
    ~List() 
    {
        while (m_head) 
        {
            remove();
        }

    }

    // Добавление узла в список
    void append(const T& t)
    {
        if (Node* node = new Node(t))
        {
            // Новый узел привязывается к старому головному элементу
            node->m_next = m_head;

            // Новый узел сам становится головным элементом
            m_head = node;
        }
    }

    // Удаление последнего добавленного узла из списка
    void remove() 
    {
        if (m_head) 
        { 
            // Сохраняем указатель на второй узел, который станет новым головным элементом
            Node* newHead = m_head->m_next;

            // Освобождаем память, выделенную для удаляемого головного элемента
            delete m_head;

            // Назначаем новый головной элемент
            m_head = newHead;
        } // Иначе могли бы возбудить исключение

    }

    // Получить головной элемент списка
    T head() const 
    {
        
    }

    // Получить размер списка
    size_t size() const
    {
    
    }

private:
    // Структура узла односвязного списка
    struct Node 
    {
        Node() : m_next(NULL) { }
        Node(const T& t) : m_t(t), m_next(NULL) { }
        // Значение узла
        T m_t;
        // Указатель на следующий узел
        Node* m_next;
    };

    // Голова односвязного списка
    Node* m_head;
};